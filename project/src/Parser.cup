//test branch
import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;


/* Preliminaries to use the lexer.  */
//scan with {: return scanner.next_token(); :};


parser code {: 
  public boolean syntaxErrors;

  //Lexer lexer;

  /*public Parser(Lexer lex) {
      super(lex);
      lexer = lex;
  }*/

  
  public void report_error(String message, Object info) {
    syntaxErrors = true;

    System.out.print(message + ": ");
    if (info instanceof Symbol) {
	    Symbol symbol = (Symbol) info;
	    
	    System.out.print("Error in line "+symbol.left+", column "+symbol.right+":  ");

	    switch(symbol.sym) {
	     case 0 : System.out.print( "EOF" ); break;
	     case 1 : System.out.print( "error" ); break;
		 case 2 : System.out.print( "UNEXPECTED EXCLAMATION"); break;
		 case 3 : System.out.print( "UNEXPECTED AMPERSANDAMPERSAND"); break;
		 case 4 : System.out.print( "UNEXPECTED MINUS"); break;
		 case 5 : System.out.print( "UNEXPECTED PLUS"); break;
		 case 6 : System.out.print( "UNEXPECTED ASTERISK"); break;
		 case 7 : System.out.print( "UNEXPECTED FSLASH"); break;
		 case 8 : System.out.print( "UNEXPECTED CARAT"); break;
		 case 9 : System.out.print( "UNEXPECTED LSQUAREBRACKET"); break;
		 case 10 : System.out.print( "UNEXPECTED RSQUAREBRACKET"); break;
		 case 11 : System.out.print( "UNEXPECTED LBRACKET"); break;
		 case 12 : System.out.print( "UNEXPECTED RBRACKET"); break;
		 case 13 : System.out.print( "UNEXPECTED COLONCOLON"); break;
		 case 14 : System.out.print( "UNEXPECTED COLON"); break;
		 case 15 : System.out.print( "UNEXPECTED LTHAN"); break;
		 case 16 : System.out.print( "UNEXPECTED MTHAN"); break;
		 case 17 : System.out.print( "UNEXPECTED PIPEPIPE"); break;
		 case 18 : System.out.print( "UNEXPECTED LTHANEQUALITY"); break;
		 case 19 : System.out.print( "UNEXPECTED IMPLICATION"); break;
		 case 20 : System.out.print( "UNEXPECTED EXCLAMATIONEQUALITY"); break;
		 case 21 : System.out.print( "UNEXPECTED SEMICOLON"); break;
		 case 22 : System.out.print( "UNEXPECTED LBRACE"); break;
		 case 23 : System.out.print( "UNEXPECTED RBRACE"); break;
		 case 24 : System.out.print( "UNEXPECTED DOT"); break;
		 case 25 : System.out.print( "UNEXPECTED COMMA"); break;
		 case 26 : System.out.print( "UNEXPECTED EQUALITY");break;
		 case 27 : System.out.print( "UNEXPECTED EQUALITYEQUALITY"); break;
		 case 28 : System.out.print( "UNEXPECTED TDEF"); break;
		 case 29 : System.out.print( "UNEXPECTED FDEF"); break;
		 case 30 : System.out.print( "UNEXPECTED WHILE"); break;
		 case 31 : System.out.print( "UNEXPECTED RETURN"); break;
		 case 32 : System.out.print( "UNEXPECTED READ"); break;
		 case 33 : System.out.print( "UNEXPECTED PRINT"); break;
		 case 34 : System.out.print( "UNEXPECTED IF"); break;
		 case 35 : System.out.print( "UNEXPECTED ELSE"); break;
		 case 36 : System.out.print( "UNEXPECTED FI"); break;
		 case 37 : System.out.print( "UNEXPECTED DO"); break;
		 case 38 : System.out.print( "UNEXPECTED OD"); break;
		 case 39 : System.out.print( "UNEXPECTED IN"); break;
		 case 40 : System.out.print( "UNEXPECTED BOOL"); break;
		 case 41 : System.out.print( "UNEXPECTED INT"); break;
		 case 42 : System.out.print( "UNEXPECTED STRING"); break;
		 case 43 : System.out.print( "UNEXPECTED RAT"); break;
		 case 44 : System.out.print( "UNEXPECTED FLOAT"); break;
		 case 45 : System.out.print( "UNEXPECTED CHAR"); break;
		 case 46 : System.out.print( "UNEXPECTED TOP"); break;
		 case 47 : System.out.print( "UNEXPECTED LEN"); break;
		 case 48 : System.out.print( "UNEXPECTED SEQ"); break;
		 case 49 : System.out.print( "UNEXPECTED THEN"); break;
		 case 50 : System.out.print( "UNEXPECTED DICT"); break;
		 case 51 : System.out.print( "UNEXPECTED MAIN"); break;
		 case 52 : System.out.print( "UNEXPECTED ALIAS"); break;

		 case 53 : System.out.print( "UNEXPECTED FORALL"); break;
		 case 54 : System.out.print( "UNEXPECTED NEGATIVESIGN"); break;
		 case 55 : System.out.print( "UNEXPECTED STRING_CONSTANT"); break;
		 case 56 : System.out.print( "UNEXPECTED RAT_CONSTANT");break;
		 case 57 : System.out.print( "UNEXPECTED IDENTIFIER"); break;
		 case 58 : System.out.print( "UNEXPECTED CHAR_CONSTANT"); break;
		 case 59 : System.out.print( "UNEXPECTED BOOL_CONSTANT"); break;
		 case 60 : System.out.print( "UNEXPECTED FLOAT_CONSTANT"); break;
		 case 61 : System.out.print( "UNEXPECTED INT_CONSTANT"); break;
		 default : System.out.print( "MISSED THE CASES"); break;
         }
         System.out.println(".");
	    
    }
  }

  /*public static void main(String args[]) throws Exception {
    new Parser(new Lexer(new java.io.FileInputStream(args[0]))).parse();
  }*/
:}; 


terminal EXCLAMATION, AMPERSANDAMPERSAND, MINUS, PLUS, ASTERISK, FSLASH, CARAT, LSQUAREBRACKET, RSQUAREBRACKET, LBRACKET, RBRACKET, COLONCOLON, COLON, LTHAN, MTHAN, PIPEPIPE, LTHANEQUALITY, IMPLICATION, EXCLAMATIONEQUALITY, SEMICOLON, LBRACE, RBRACE, DOT, COMMA, EQUALITY, EQUALITYEQUALITY, TDEF, FDEF, WHILE, RETURN, READ, PRINT, IF, ELSE, FI, DO, OD, IN, BOOL, INT, RAT, FLOAT, CHAR, TOP, LEN, SEQ, THEN, DICT, MAIN, ALIAS, FORALL, NEGATIVESIGN;

terminal String STRING_CONSTANT, RAT_CONSTANT, IDENTIFIER, CHAR_CONSTANT;
terminal Boolean BOOL_CONSTANT;
terminal Float FLOAT_CONSTANT; 
terminal Integer INT_CONSTANT;

non terminal seq_constant, dict_constant, statement, expr, type, listdeclaration, main, program, declaration, functionDef, dataTypeDef, aliasDef, dataTypeDeclarationList, dataTypeDeclaration, primitiveDataType, aggregateDataType, sequenceType, dictType, typeseqdict, formal_parameter_list, funcBody, returnType, functionParamsList, localVarDecs, statementDecs, variableDef, readStatement, printStatement, functionCallStatement, ifStatement, whileLoopStatement, forAllLoopStatement, returnStatement, assignment, functionCallExpr, paramsListOptions, paramsList, optionalElse, elseStatement, iterable, dictListOptions, dictList, lenExpr, other, valueOfIndex, substrValue, index, substr, body_declaration_list_opt, statements_list_opt, body_declaration, statements_list;

precedence left PIPEPIPE, AMPERSANDAMPERSAND, IMPLICATION;
precedence left EQUALITYEQUALITY, LTHAN, MTHAN, LTHANEQUALITY, EXCLAMATIONEQUALITY;
precedence left PLUS, MINUS;
precedence left IN, COLONCOLON;
precedence left ASTERISK, FSLASH;
precedence left CARAT;
precedence left EXCLAMATION, NEGATIVESIGN;
precedence left LBRACKET, RBRACKET;



program ::= listdeclaration main listdeclaration;

listdeclaration ::= | declaration listdeclaration;

declaration ::= functionDef | variableDef | dataTypeDef | aliasDef;

dataTypeDef ::= TDEF IDENTIFIER LBRACE dataTypeDeclarationList RBRACE SEMICOLON;

dataTypeDeclarationList ::= | dataTypeDeclaration;

dataTypeDeclaration ::= IDENTIFIER COLON type | IDENTIFIER COLON type COMMA dataTypeDeclaration;

type ::= IDENTIFIER | primitiveDataType | aggregateDataType; 

primitiveDataType ::= BOOL | INT | RAT | FLOAT | CHAR;

aggregateDataType ::= sequenceType | dictType;

sequenceType ::= SEQ LTHAN typeseqdict MTHAN;

typeseqdict ::= type | TOP;

dictType ::= DICT LTHAN typeseqdict COMMA typeseqdict MTHAN;

aliasDef ::= ALIAS type IDENTIFIER SEMICOLON;

functionDef ::= FDEF IDENTIFIER LBRACKET formal_parameter_list RBRACKET LBRACE funcBody RBRACE returnType SEMICOLON;

formal_parameter_list ::= | functionParamsList;

functionParamsList ::= IDENTIFIER COLON type | IDENTIFIER COLON type COMMA functionParamsList;

returnType ::= | COLON type;

//globalVarDef ::= IDENTIFIER COLON type EQUALITY expr SEMICOLON;

main ::= MAIN LBRACE funcBody RBRACE;

funcBody ::= body_declaration_list_opt statements_list_opt;

body_declaration_list_opt ::= | body_declaration body_declaration_list_opt;

body_declaration ::= variableDef | aliasDef | dataTypeDef;





statements_list_opt ::= | statements_list;

statements_list ::= statement | statement statements_list;


//localVarDecs ::=  | variableDef localVarDecs;

// 1 or more localvariables | 1 or more sequences

variableDef ::= IDENTIFIER COLON type EQUALITY expr SEMICOLON;

//statementDecs ::= | statement statementDecs;

statement ::= readStatement | printStatement | functionCallStatement | ifStatement | whileLoopStatement | forAllLoopStatement | returnStatement | assignment;

readStatement ::= READ IDENTIFIER SEMICOLON;

printStatement ::= PRINT expr SEMICOLON;

functionCallStatement ::= functionCallExpr SEMICOLON; 

functionCallExpr ::= IDENTIFIER LBRACKET paramsListOptions RBRACKET;

paramsListOptions ::= | paramsList;

paramsList ::= expr | expr COMMA paramsList;

ifStatement ::= IF LBRACKET expr RBRACKET THEN funcBody optionalElse FI;

optionalElse ::= | elseStatement;

elseStatement ::= ELSE funcBody;

whileLoopStatement ::= WHILE LBRACKET expr RBRACKET DO funcBody OD;

forAllLoopStatement ::= FORALL LBRACKET IDENTIFIER IN iterable RBRACKET DO funcBody OD;

iterable ::= dict_constant | seq_constant;

dict_constant ::= LBRACE dictListOptions RBRACE;

seq_constant ::= LSQUAREBRACKET paramsListOptions RSQUAREBRACKET;

dictListOptions ::= | dictList;

dictList ::= expr COLON expr | expr COLON expr COMMA dictList;

returnStatement ::= RETURN expr SEMICOLON | RETURN SEMICOLON;

//maybe should be updated to allow assigning value to index, and not to allow assigning value to an arry index returned from function

assignment ::= IDENTIFIER EQUALITY expr SEMICOLON | IDENTIFIER LSQUAREBRACKET expr RSQUAREBRACKET EQUALITY expr SEMICOLON; 

expr ::= expr AMPERSANDAMPERSAND expr 
		| expr PIPEPIPE expr
		| EXCLAMATION expr
		| MINUS expr %prec NEGATIVESIGN /*check what this does*/
		| expr PLUS expr
        | expr MINUS expr
        | expr CARAT expr
        | expr FSLASH expr
        | expr ASTERISK expr
        | expr LTHAN expr
        | expr LTHANEQUALITY expr
        | expr MTHAN expr
        | expr EQUALITYEQUALITY expr
        | expr EXCLAMATIONEQUALITY expr
        | expr IMPLICATION expr
        | expr COLONCOLON expr
        | INT_CONSTANT
        | FLOAT_CONSTANT
        | BOOL_CONSTANT
        | STRING_CONSTANT
        | CHAR_CONSTANT
        | RAT_CONSTANT
        | seq_constant
        | dict_constant
        | LBRACKET expr RBRACKET
        | lenExpr
        | expr IN expr
        | other
        ;



lenExpr ::= LEN LBRACKET expr RBRACKET;

other ::= functionCallExpr | IDENTIFIER | valueOfIndex | substrValue | IDENTIFIER DOT IDENTIFIER | functionCallExpr DOT IDENTIFIER;

index ::= LSQUAREBRACKET expr RSQUAREBRACKET;

valueOfIndex ::= IDENTIFIER index | functionCallExpr index | LBRACKET expr RBRACKET index;

substr ::= LSQUAREBRACKET expr COLON expr RSQUAREBRACKET | LSQUAREBRACKET expr COLON RSQUAREBRACKET | LSQUAREBRACKET COLON expr RSQUAREBRACKET;

substrValue ::= IDENTIFIER substr | functionCallExpr substr | LBRACKET expr RBRACKET substr;



//seq::= IDENTIFIER COLON SEQ LTHAN typeseqdict MTHAN EQUALITY LSQUAREBRACKET commaseparatedlist RSQUAREBRACKET SEMICOLON;

/*commaseparatedlist ::= | commaseparated;

commaseparated ::= expr | expr COMMA commaseparated;

dict::= IDENTIFIER COLON DICT LTHAN typeseqdict COMMA typeseqdict MTHAN EQUALITY LBRACE dictcontents RBRACE SEMICOLON;

dictcontents ::= | dictcontentsexpr;

dictcontentsexpr ::= expr | expr COMMA dictcontentsexpr;


lenOperator ::= LEN LBRACKET expr RBRACKET;
indexOperator ::= IDENTIFIER LSQUAREBRACKET expr RSQUAREBRACKET;

seqSlice ::= IDENTIFIER LSQUAREBRACKET expr COLON expr RSQUAREBRACKET | IDENTIFIER LSQUAREBRACKET COLON expr RSQUAREBRACKET | IDENTIFIER LSQUAREBRACKET expr COLON RSQUAREBRACKET;



*/




//all code underneath this is from last years cw

/*

block ::= statement block | | error block ;

tdef ::= TDEF IDENTIFIER COLON inhabitedCommaSeparatedIdentifierKeyList ;

inhabitedCommaSeparatedIdentifierKeyList ::= IDENTIFIER COLON expr COMMA inhabitedCommaSeparatedIdentifierKeyList | IDENTIFIER COLON expr;

varDeclaration ::= varSpec EQUALITY expr | varSpec;
varSpec ::= IDENTIFIER IDENTIFIER;

funDeclaration ::= FDEF IDENTIFIER IDENTIFIER LBRACKET commaSeparatedVarSpecList RBRACKET LBRACE block RBRACE;

variable ::= IDENTIFIER | sequenceAccess | expr DOT IDENTIFIER;
varAssignment ::= variable EQUALITY expr;

statement ::= varAssignment SEMICOLON | READ variable SEMICOLON | PRINT commaSeparatedList SEMICOLON | RETURN expr SEMICOLON | IF LBRACKET expr RBRACKET LBRACE block RBRACE ELSE LBRACE block RBRACE | WHILE expr DO LBRACE block RBRACE | FOREACH LBRACKET expr COLON IDENTIFIER RBRACKET LBRACE block RBRACE | expr SEMICOLON | varDeclaration SEMICOLON | tdef SEMICOLON | funDeclaration | SEMICOLON;

expr ::= variable | dict | list | expr PLUS expr | expr MINUS expr | expr ASTERISK expr | expr FSLASH expr | expr CARAT expr | STRING_CONSTANT | CHAR_CONSTANT | INT_CONSTANT | FLOAT_CONSTANT | expr IN expr | expr PIPEPIPE expr | expr AMPERSANDAMPERSAND expr | expr LTHAN expr | expr LTHANEQUALITY expr | expr EQUALITYEQUALITY expr | expr EXCLAMATIONEQUALITY expr | expr COLONCOLON expr | EXCLAMATION expr | IDENTIFIER seq | LBRACKET expr RBRACKET | sequenceSlice;

sequenceSlice ::= expr LSQUAREBRACKET expr COLON expr RSQUAREBRACKET;
sequenceAccess ::= expr LSQUAREBRACKET expr RSQUAREBRACKET;

list ::= LSQUAREBRACKET commaSeparatedList RSQUAREBRACKET;
commaSeparatedList ::= | inhabitedCommaSeparatedList;
inhabitedCommaSeparatedList ::= expr COMMA inhabitedCommaSeparatedList | expr;

dict ::= LBRACE commaSeparatedKeyList RBRACE; 
commaSeparatedKeyList ::= | inhabitedCommaSeparatedKeyList;
inhabitedCommaSeparatedKeyList ::= expr COLON expr COMMA inhabitedCommaSeparatedKeyList | expr COLON expr;

commaSeparatedVarSpecList ::= | inhabitedCommaSeparatedVarSpecList;
inhabitedCommaSeparatedVarSpecList ::= varSpec COMMA  inhabitedCommaSeparatedVarSpecList | varSpec;

seq ::= LBRACKET commaSeparatedList RBRACKET;
*/
